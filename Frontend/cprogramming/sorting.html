<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting and Searching in C - CodeProgramix</title>
    <link rel="stylesheet" href="all-cse.css">
</head>
<body>
    <header>
        <nav>
            <div class="logo">CodeProgramix</div>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../about.html">About</a></li>
                <li><a href="../course.html">Course</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section class="course-details">
            <h1>Sorting and Searching in C</h1>
            <p>
                Sorting and searching algorithms are essential in computer science for organizing and finding data efficiently. Below is an overview of common sorting algorithms (Bubble Sort, Insertion Sort, and Selection Sort) and searching algorithms (Binary Search and Linear Search) in C, along with their advantages, disadvantages, and examples.
            </p>

            <h2>1. Bubble Sort</h2>
            <p><strong>Description:</strong> Bubble Sort is a simple comparison-based sorting algorithm where adjacent elements are compared and swapped if they are in the wrong order. This process is repeated for every element in the array until the array is sorted.</p>
            <h3>Algorithm:</h3>
            <ul>
                <li>Compare adjacent elements.</li>
                <li>Swap them if they are in the wrong order.</li>
                <li>Repeat the process for all elements in the list.</li>
                <li>Continue this process until no more swaps are needed.</li>
            </ul>
            <h3>Example:</h3>
            <pre><code>#include &lt;stdio.h&gt;
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr)/sizeof(arr[0]);
    bubbleSort(arr, n);
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}
            </code></pre>
             <p><a href="https://www.programiz.com/c-programming/online-compiler/" target="_blank">Copy and,Test this codeðŸ‘† </a></p>
            <h3>Advantages:</h3>
            <ul>
                <li>Simple and easy to implement.</li>
                <li>Good for small datasets.</li>
                <li>Adaptive (can perform well if the list is already partially sorted).</li>
            </ul>
            <h3>Disadvantages:</h3>
            <ul>
                <li>Time complexity is O(nÂ²) in the worst and average cases.</li>
                <li>Inefficient for large datasets.</li>
            </ul>

            <h2>2. Insertion Sort</h2>
            <p><strong>Description:</strong> Insertion Sort builds the final sorted array one item at a time. It takes each element and inserts it into the correct position in the already sorted part of the array.</p>
            <h3>Algorithm:</h3>
            <ul>
                <li>Start from the second element, and compare it with the elements before it.</li>
                <li>Shift elements greater than the current element one position to the right.</li>
                <li>Insert the current element in its correct position.</li>
            </ul>
            <h3>Example:</h3>
            <pre><code>#include &lt;stdio.h&gt;

void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr)/sizeof(arr[0]);
    insertionSort(arr, n);
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}

            </code></pre>
            <p><a href="https://www.programiz.com/c-programming/online-compiler/" target="_blank">Copy and,Test this codeðŸ‘† </a></p>
            <h3>Advantages:</h3>
            <ul>
                <li>Simple to implement.</li>
                <li>Efficient for small datasets or nearly sorted arrays.</li>
                <li>Stable sort (does not change the relative order of elements with equal values).</li>
            </ul>
            <h3>Disadvantages:</h3>
            <ul>
                <li>Time complexity is O(nÂ²) in the worst case.</li>
                <li>Inefficient for large datasets.</li>
            </ul>

            <h2>3. Selection Sort</h2>
            <p><strong>Description:</strong> Selection Sort repeatedly finds the minimum element from the unsorted part of the array and swaps it with the first unsorted element.</p>
            <h3>Algorithm:</h3>
            <ul>
                <li>Find the smallest element in the unsorted part.</li>
                <li>Swap it with the first unsorted element.</li>
                <li>Repeat the process for all elements.</li>
            </ul>
            <h3>Example:</h3>
            <pre><code>#include &lt;stdio.h&gt;

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        int minIdx = i;
        for (int j = i+1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        int temp = arr[minIdx];
        arr[minIdx] = arr[i];
        arr[i] = temp;
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr)/sizeof(arr[0]);
    selectionSort(arr, n);
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}

            </code></pre>
            <p><a href="https://www.programiz.com/c-programming/online-compiler/" target="_blank">Copy and,Test this codeðŸ‘† </a></p>
            <h3>Advantages:</h3>
            <ul>
                <li>Simple and easy to implement.</li>
                <li>Doesn't require extra space (in-place sort).</li>
                <li>Works well for small datasets.</li>
            </ul>
            <h3>Disadvantages:</h3>
            <ul>
                <li>Time complexity is O(nÂ²) in all cases.</li>
                <li>Not efficient for large datasets.</li>
            </ul>

            <h2>Searching Algorithms</h2>

            <h3>4. Linear Search</h3>
            <p><strong>Description:</strong> Linear Search is the simplest searching algorithm. It checks every element in the array sequentially until the desired element is found or the entire array is traversed.</p>
            <h3>Algorithm:</h3>
            <ul>
                <li>Start from the first element and compare it with the target.</li>
                <li>Continue comparing each subsequent element until the target is found or the end of the list is reached.</li>
            </ul>
            <h3>Example:</h3>
            <pre><code>#include &lt;stdio.h&gt;
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr)/sizeof(arr[0]);
    int target = 25;
    int result = linearSearch(arr, n, target);
    if (result != -1) {
        printf("Element found at index %d\n", result);
    } else {
        printf("Element not found\n");
    }
    return 0;
}
            </code></pre>
            <p><a href="https://www.programiz.com/c-programming/online-compiler/" target="_blank">Copy and,Test this codeðŸ‘† </a></p>
            <h3>Advantages:</h3>
            <ul>
                <li>Very simple to implement.</li>
                <li>Works on unsorted and sorted data.</li>
                <li>No additional space required.</li>
            </ul>
            <h3>Disadvantages:</h3>
            <ul>
                <li>Time complexity is O(n), making it inefficient for large datasets.</li>
                <li>It may need to search through all elements.</li>
            </ul>

            <h3>5. Binary Search</h3>
            <p><strong>Description:</strong> Binary Search is an efficient algorithm for finding a target value in a sorted array. It works by repeatedly dividing the search interval in half.</p>
            <h3>Algorithm:</h3>
            <ul>
                <li>Start with the middle element of the array.</li>
                <li>If the target value is equal to the middle element, return the index.</li>
                <li>If the target is less than the middle element, search in the left half.</li>
                <li>If the target is greater, search in the right half.</li>
                <li>Repeat the process until the target is found or the search interval is empty.</li>
            </ul>
            <h3>Example:</h3>
            <pre><code>#include &lt;stdio.h&gt;
int binarySearch(int arr[], int n, int target) {
    int low = 0, high = n - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) {
            return mid;
        }
        if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;
}

int main() {
    int arr[] = {11, 12, 22, 25, 34, 64, 90};
    int n = sizeof(arr)/sizeof(arr[0]);
    int target = 25;
    int result = binarySearch(arr, n, target);
    if (result != -1) {
        printf("Element found at index %d\n", result);
    } else {
        printf("Element not found\n");
    }
    return 0;
}

            </code></pre>
            <p><a href="https://www.programiz.com/c-programming/online-compiler/" target="_blank">Copy and,Test this codeðŸ‘† </a></p>
            <h3>Advantages:</h3>
            <ul>
                <li>Time complexity is O(log n), making it much faster than Linear Search for large datasets.</li>
                <li>Efficient for large sorted arrays.</li>
            </ul>
            <h3>Disadvantages:</h3>
            <ul>
                <li>Only works on sorted arrays.</li>
                <li>Requires random access to the array (not suitable for linked lists).</li>
            </ul>
            <h2>Some Questions:</h2>
            <ol>
                <li><strong>What is the time complexity of Bubble Sort in the best, average, and worst cases?</strong><br>
                    Best Case: O(n) (when the array is already sorted).<br>
                    Average Case: O(nÂ²) (typical case where elements are randomly ordered).<br>
                    Worst Case: O(nÂ²) (when the array is sorted in reverse order).
                </li>

                <li><strong>How does Insertion Sort differ from Bubble Sort in terms of operation and efficiency?</strong><br>
                    Insertion Sort builds the sorted array one element at a time by inserting each new element into its correct position in the already sorted part of the array. It works well for small or nearly sorted arrays.<br>
                    Bubble Sort repeatedly swaps adjacent elements if they are in the wrong order. Itâ€™s simple but inefficient for large datasets.<br>
                    Efficiency: Both have O(nÂ²) time complexity in the worst and average cases. Insertion Sort performs better in practice because it moves elements fewer times than Bubble Sort, especially if the array is nearly sorted.
                </li>

                <li><strong>Explain why Selection Sort is considered inefficient for large datasets.</strong><br>
                    Selection Sort has a time complexity of O(nÂ²) in all cases (best, average, and worst). It repeatedly finds the minimum element and swaps it with the first unsorted element, resulting in unnecessary comparisons and swaps, making it inefficient for large datasets.
                </li>

                <li><strong>Which sorting algorithm would be more efficient for sorting a nearly sorted array, and why?</strong><br>
                    Insertion Sort is more efficient for nearly sorted arrays because its best-case time complexity is O(n) when the array is already sorted or nearly sorted. Insertion Sort performs fewer shifts in such cases compared to other algorithms like Bubble Sort or Selection Sort.
                </li>

                <li><strong>What is the space complexity of Bubble Sort, and how does it compare to other sorting algorithms like MergeSort or QuickSort?</strong><br>
                    Bubble Sort has a space complexity of O(1) because it is an in-place sorting algorithm.<br>
                    MergeSort has a space complexity of O(n) due to the need for additional arrays to store the left and right halves of the array.<br>
                    QuickSort has a space complexity of O(log n) in the average case (due to recursion), though it can degrade to O(n) in the worst case if the pivot selection is poor.
                </li>

                <li><strong>Which of the following sorting algorithms is stable: Bubble Sort, Selection Sort, or Insertion Sort? Justify your answer.</strong><br>
                    Stable Sorts: Bubble Sort and Insertion Sort are stable sorting algorithms because they preserve the relative order of equal elements.<br>
                    Unstable Sort: Selection Sort is unstable because it may swap equal elements and change their original order.
                </li>

                <li><strong>What is the time complexity of Linear Search in the best, average, and worst cases?</strong><br>
                    Best Case: O(1) (when the target element is the first element).<br>
                    Average Case: O(n) (when the target is in the middle of the array).<br>
                    Worst Case: O(n) (when the target element is not present, or it is the last element).
                </li>

                <li><strong>Why is Binary Search faster than Linear Search, and under what conditions can Binary Search be applied?</strong><br>
                    Binary Search is faster because it works by repeatedly halving the search space, resulting in a time complexity of O(log n), whereas Linear Search checks each element one by one, resulting in O(n) time complexity.<br>
                    Binary Search can only be applied to sorted arrays, as it assumes that the elements are ordered.
                </li>

                <li><strong>What would happen if you apply Binary Search to an unsorted array?</strong><br>
                    Binary Search would not work on an unsorted array because it relies on the array being ordered. Applying it to an unsorted array would give incorrect results or potentially lead to an infinite loop.
                </li>

                <li><strong>Explain the differences between Linear Search and Binary Search in terms of their implementation, efficiency, and requirements.</strong><br>
                    Linear Search:<br>
                    Implementation: Simple and checks each element in sequence.<br>
                    Efficiency: O(n) in the worst case.<br>
                    Requirements: Works on unsorted and sorted arrays.<br><br>
                    Binary Search:<br>
                    Implementation: Divides the array into halves and checks the middle element.<br>
                    Efficiency: O(log n) in the worst case.<br>
                    Requirements: Works only on sorted arrays.
                </li>
            </ol>
            <a href="string.html" class="back-button">Previous page</a>
            <a href="file.html" class="back-button">Next page</a>
        </section>
    </main>

    <footer>
        <div class="footer-content">
            <div class="footer-section">
                <h3>Quick Links</h3>
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../about.html">About</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h3>Contact Us</h3>
                <p>Email: codeprogramix@gmail.com</p>
                <p>Phone: +91 9973186195</p>
            </div>
            <div class="footer-section">
                <h3>Follow Us</h3>
                <div class="social-icons">
                    <a href="#" aria-label="Facebook"><img src="icons8-facebook.svg" alt="Facebook Icon"></a>
                    <a href="#" aria-label="Twitter"><img src="icons8-instagram.svg" alt="Twitter Icon"></a>
                    <a href="#" aria-label="LinkedIn"><img src="icons8-linkedin.svg" alt="LinkedIn Icon"></a>
                </div>
            </div>
        </div>
        <p class="copyright">&copy; 2026 CodeProgramix. All rights reserved.</p>
    </footer>
</body>
</html>
